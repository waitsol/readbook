1，虚函数问题
一般来说，多重继承编译器不会改变继承顺序，Device类的新虚函数一般是跟随最左边 的第一张虚函数表
2，数据问题，
数据是和最右边的在一起

win下

虚函数子类也是和第一个父类合并，然后分别是虚函数表 虚基类 数据,第二个父类的虚函数表 虚基类 数据。。。 最后是虚基类数据(表和数据)
虚基类表 第一个数据是和虚函数表的偏移量，第二个是和虚基类的偏移量
虚函数表 分别保存自己的虚函数 子类的和第一个父类合并 ，就算父类重写了的虚基类的虚函数，依然去虚基类的虚函数的表查找
数据继承的类会根据有没有虚函数排序吗，有自己的虚函数的在前面，子类数据跟最后一个没有独立虚函数的合并，如果都有独立虚函数的话，跟最后一个合并

Linux 
无论父类有没有自己的虚函数 子类数据是和最右边的父类数据在一起
linux下虚函数比较简单，在样例中分别是 class vdecive b ,vdecive c ,vdecive d表的虚函数和数据
printAddrFunc(pvd, 4);
// vc
printAddrFunc(pvd + 3, 2);
// vfa
printAddrFunc(pvd + 6, 1);
//段错误,虚函数没有重写不知道为什么4个表都找不到
    //printAddrFunc(pvd +11, 1);
//特殊打印 通过g++ -fdump-lang-class 3.cpp  -I../include/观看内存布局可以看到 vbase在下标2的地方
_func *vptr = reinterpret_cast<_func *>(*static_cast<int64_t *>(pvd + 11));